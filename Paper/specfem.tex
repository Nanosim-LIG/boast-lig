


\subsection{Porting SPECFEM3D to OpenCL using BOAST}
\label{subsec:specfem}

\subsubsection{SPECFEM3D}

In this last subsection, we study a free seismic wave propagation
simulator, \Specfem, in its \productname{Cartesian}
flavor\footnote{Specfem3d Cartesian --- CIG
  \url{http://www.geodynamics.org/cig/software/specfem3d}}. \Specfem
simulates seismic wave propagation at the local or regional scale
based upon spectral-element method (SEM), with very good accuracy and
convergence properties. ADD BENCHMARK APP FOR HPC SUPERCOMPUTERS.

When we started to work on the project (version v2.1 of July 2013) it
supported graphics card GPU acceleration through NVidia \Cuda. This
GPU support came in addition to the MPI support implemented to enable
multi-CPU parallel computing. Most of \Specfem code-base is written in
\productname{Fortran2003}, only the GPU related parts are written in
C.  The split between CPU and GPU code was done at a rather fine
grain, as the application counted more than 40 GPU kernels. Some of
them were quite simple (\eg performing a few vector operations, but at
massively parallel scale), while at the other side of the spectrum,
some complex kernels took more than 80 parameters and perform very
specific physical transformations.

Because of the complexity of wave propagation (and of the application
architecture), it is hard to impossible to define unit tests. Hence,
the application is validated by the accuracy of the results it
produces, that is, the accuracy of seismograms of the simulated
earthquakes, in comparison with the actual ones. Non-regression
testing (after new developments) is also based on these seismograms,
with measurements of the relative error between two identical
simulations.

As part of the Mont-Blanc project, we had to port \Specfem to \OCL, so
that it could be use to benchmark Mont-Blanc HPC platform.

\subsubsection{Porting to OpenCL}

\subparagraph{Porting kernels to BOAST} 

Nvidia \Cuda and \OCL are based on the same programming model: a
massively parallel accelerator running in disjoint, non addressable
memory environment. Thanks to that proximity, we, BOAST developers,
have been able to carry out most of the porting task with only a
limited knowledge about \Specfem internal physics.

This lack of \Specfem internal knowledge led us to be particularly
attentive to the path we undertook for the porting, as we would have
been unable to understand how and why the application was not
operating properly, if it was to fail.

Hence, our first milestone in the porting was the translation of
\Specfem's \Cuda kernels into BOAST EDSL. This way, we could ask BOAST
framework to generate a CUDA version of the kernels, plug them back
into \Specfem and get (after fixing compile-time errors---prototypes
and naming mistakes mainly) a first set of \Specfem seismograms.

As we had expected, the seismograms were erroneous. But with the help
of shell scripts and BOAST framework ability to store and provide the
kernels' original source code, we built a set of \Specfem binaries
including only \emph{one} BOAST-generated kernel, with all others
reference-kernels. Running and validating all these binaries enabled
use to pinpoint the misbehaving kernels. We finished the debugging
with a side-by-side comparison that highlighted the coding mistakes.

\subparagraph{Porting runtime to \OCL} The second part of the porting
consisted in the translation of the CPU-side of the application, from
\Cuda API to \OCL API. Most of the functions of the interfaces are
very similar, with only naming-convention and data-structure
distinctions. Hence, it was clear that automatic rewriting tools
(namely \code{sed} regexp and \code{emacs-lisp} functions) could be
useful. To give an idea of the cost of a \emph{manual} rewriting, we
can count (in \# of \OCL API function calls): 70 kernel ``function
calls'', 790 arguments to set, 230 memory transfers, 160 buffer
creations and 270 releases.

Once all the automatic (and many manual) transformations were applied,
compilation errors fixed, and \OCL unsuccessful function calls solved,
the application managed to complete its execution and generate a first
set of seismograms. And again, as expected and feared, these
seismograms were not valid.

As we had already validated BOAST-generated kernels (and trusted \Cuda
and \OCL versions to be semantically identical), we knew that the bugs
were now in the CPU side, and we had to find a way to understand where
\Specfem's \Cuda version of the code diverged from its \OCL
counterpart. To help us in that purpose, we had a strong assumption:
both versions of the code were supposed to perform exactly the same
operations, with the same ``logical'' parameters (the APIs have
\emph{implementation} differences, for instance \OCL has two memory
transfer functions, \code{clEnqueueReadBuffer},
\code{clEnqueueWriteBuffer}, whereas \Cuda has only one, with a
direction parameter \code{cudaMemcpy(..., dir)}, but above that, it is
the same functionalities).

Hence, our idea for locating the execution problems was to make sure
that both execution actually did the same thing. As the \OCL results
were invalid, we knew the executions would diverge at one or several
points.

\subparagraph{Debugging \OCL Execution: \code{GPUTrace}} 

With the help of \code{GPUTrace} (Section~\ref{sec:gputrace}), we
could to confront \Cuda and \OCL execution traces with a graphical
\code{diff} tool, and spot the different porting mistakes: some
parameters reversed, offsets incorrectly applied, \etc{}. 

One last problem remained, clearly highlighted by the seismograms not
matching perfectly (they had a similar shape, but with a reduced
intensity). We added more verbosity to \code{GPUTrace} output: first
the initial bits of the GPU memory buffers, then their full
content. The drift was visible in the trace, but it was nonetheless
unclear where it started. We finally got it after hours of code review
of BOAST kernels and \OCL code: one kernel was
\emph{three}-dimensional, whereas the others were two-dimensional. But
for all of them, only two dimensions were passed, and one was
missing. As it was the same person who coded the \OCL port and the GPU
tracer, this third dimension was forgotten in both codes\ldots

\subparagraph{Evaluation} Our \OCL/BOAST port of \Specfem is now
merged in \Specfem's development tree and under test and extension by
different research teams. On a platform with two K40x GPUs and N Intel
Xeon processors, we measured similar results between the original
\Cuda version and our BOAST-\Cuda version. With the same set of
optimization flags, BOAST \Cuda and \OCL version reported similar
execution time spans. The best execution speed was achieved with \Cuda
version though (25\% higher than \OCL), as one optimization parameter
(\code{CUDA\_LAUNCH\_BOUND}) cannot be passed, to \OCL runtime, as of
version 1.1.

By refactoring GPU kernel code in BOAST EDSL, the size of kernel code
shrank by a factor of 1.5 (from xxx LOC to xxx, partly because of code
duplication, but by removing manually unrolled loops). This is
beneficial for \Specfem as it improves the readability and
maintainability of its source code.

We have also been able to enhance \Specfem's non-regression testsuite
by adding per-kernel non-regression tests. This was done with the help
of \code{GPUTrace}, that we used to capture all the input parameters
of a particular \emph{valid} kernel execution, as well as the output
values. Then, during the non-regression testing, BOAST framework can
load these buffer files, allocate GPU memory and initialize it through
\Cuda or \OCL runtime, and trigger the kernel execution. A comparison
of the output values (for instance against a maximal error level)
validates the non-regression.

In the same mindset, we provided \Specfem testsuite with kernel
performance evaluation mechanisms. These tests will help developers to
try new optimization in kernel code and measure their impact, without
executing the whole application.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Local Variables:      %%%
%%% mode: latex           %%%
%%% TeX-master: "journal" %%%
%%% TeX-PDF-mode: t       %%%
%%% End:                  %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
